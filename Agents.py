from mesa import Agent
from numpy import random
from abm_functions import  ClosestAgent, get_random_alphanumeric_string, add_tree_data, connect_db

class PrimAgent(Agent):

    '''A monkey that does pounding tool activities'''

    def __init__(self, unique_id, model):
        super().__init__(unique_id, model)
        self.Has_tool = -1
        self.search_radius = self.model.search_radius
        self.NutTreeLoc = -1
        self.StoneLoc = -1
        self.Tool_size = -1
        self.Tool_id = -1
        self.Source_id = -1
        self.rm_qual = -1
        self.active = -1

    def CheckForTree(self):

        ''''PrimAgent checks to see if there is a tree at its location or in one of its neighboring cells. If yes,
        then the attribute NutTreeLoc is updated with the location of the tree. If there is more than one tree present
         then the agent will randomly choose a tree within the neighborhood'''

        neighborhood = self.model.grid.get_neighborhood(self.pos, radius=1, moore=True,include_center=True)
        neighborhood = self.model.grid.get_cell_list_contents(neighborhood)
        trees = [obj for obj in neighborhood if isinstance(obj, NutTree)]
        # this_cell = self.model.grid.get_cell_list_contents([self.pos])
        #tree = [obj for obj in this_cell if isinstance(obj, NutTree)]
        if len(trees) > 0:
            #print("I Found a Tree")
            tree = random.choice(trees)
            self.NutTreeLoc = tree.pos
        else:
            pass

    def BreakStone(self, stone):

        fragment = stone.Tool_size

        while fragment >= stone.Tool_size:
            fragment = random.exponential(200, 1)[0]

        stone.Tool_size = stone.Tool_size - fragment
        parent_id = stone.tool_id
        if stone.Tool_size < 2000:
            stone.active = False
            stone.ts_died = self.model.timestep
        else:
            pass

        if fragment >= 2000:
            active = True
        else:
            active = False

        new_tool = PoundingTool(self.model.next_id(),
                                self.model,
                                fragment,
                                active,
                                stone.source_id,
                                parent_id=parent_id,
                                q=stone.rm_quality,
                                born=self.model.timestep)

        new_tool.ts_died = self.model.timestep

        self.model.grid.place_agent(new_tool, self.pos)
        self.model.schedule.add(new_tool)

    def CheckForStone(self):

        neighborhood = self.model.grid.get_neighborhood(self.pos, radius=self.search_radius, moore=True)
        neighborhood = self.model.grid.get_cell_list_contents(neighborhood)
        stones = [obj for obj in neighborhood if isinstance(obj, StoneSource)]
        pounding = [obj for obj in neighborhood if isinstance(obj, PoundingTool)]
        pounding_filtered = []

        ### Remove objects that are not active.
        for i in range(len(pounding)):
            subset = pounding[i]
            if subset.active is True:
                pounding_filtered.append(subset)
            else:
                pass

        stones = stones + pounding_filtered

        return(stones)

    def SelectStone(self, stone_list, selection_method):
        '''
        :param stone_list: a list of locations of stones or sources generated by the CheckForStone method
        :param selection_method: a string determining the way in which PrimAgents selects a stone. Two options random or
        nearest
        :return:
        '''

        if selection_method == 'random':

            stone = random.choice(stone_list)

        elif selection_method == 'nearest':

            nearest = ClosestAgent(self.pos,list=stone_list)
            stone = stone_list[nearest]
        else:
            pass

        return(stone)


    def UseStone(self, stone):

        if type(stone) is StoneSource:
            #print("this is from the source")
            self.StoneLoc = stone.pos
            self.Source_id = stone.unique_id
            self.rm_qual = stone.rm_quality

            while self.Tool_size < 2000:
                self.Tool_size = random.normal(7400,3900,1)[0] ### Size of the tool is randomly drawn from a normal distribution with the mean and sd of tools found in the Tai forest

            self.Has_tool = 1
            self.model.grid.move_agent(self, self.StoneLoc)
            # Using the stone
            possible_steps = self.model.grid.get_neighborhood(self.NutTreeLoc, moore=True)
            new_position = self.random.choice(possible_steps)
            self.model.grid.move_agent(self, new_position)

            # Dropstone

            size = self.Tool_size
            x, y = self.pos
            source_id = self.Source_id
            ts = self.model.timestep
            tool = PoundingTool(self.model.next_id(), self.model, tool_size=size, active=True, s_id=source_id, q=self.rm_qual,born=ts)
            tool.n_uses += 1
            self.model.grid.place_agent(tool, (x, y))
            self.model.schedule.add(tool)

        elif type(stone) is PoundingTool:

            #print("this is a previously used stone")

            possible_steps = self.model.grid.get_neighborhood(self.NutTreeLoc, moore=True, include_center=True)
            new_position = self.random.choice(possible_steps)

            #new_position = self.NutTreeLoc
            self.model.grid.move_agent(self, new_position)
            #print("moving stone")
            stone.n_uses += 1
            self.model.grid.move_agent(stone, new_position)
            Break_prob = random.randint(1,100)

            if Break_prob <= 25 + stone.rm_quality:

                #identifier = self.model.next_id()
                self.BreakStone(stone)

            else:
                pass

        else:
            #print("no stone")
            pass

        ### Reset everything
        self.NutTreeLoc = -1
        self.Tool_size = -1
        self.Tool_id = -1
        self.StoneLoc = -1
        self.NutTreeLoc = -1
        self.Has_tool = -1

    def move(self):

        possible_steps = self.model.grid.get_neighborhood(
            self.pos,
            moore=True,
            include_center=False)

        new_position = self.random.choice(possible_steps)
        self.model.grid.move_agent(self, new_position)


    def step(self):

        self.CheckForTree()

        if self.NutTreeLoc != -1:

            stones = self.CheckForStone()

            if len(stones) > 0:

                stone = self.SelectStone(stones, selection_method=self.model.tool_acquistion)
                self.UseStone(stone)

            else:
                self.NutTreeLoc = -1

        else:
            pass

        # if self.Has_tool == 1:
        #     print("Using Stone")
        #     self.UseStone()
        # else:
        #     pass

        self.move()

class StoneSource(Agent):

    def __init__(self, unique_id, model, qual):
        super().__init__(unique_id, model)
        self.ID = unique_id
        self.active = -1
        self.rm_quality = qual


class NutTree(Agent):

    def __init__(self, unique_id, model, ts_born = 0, ts_died = -1):
        super().__init__(unique_id, model)
        self.ID = unique_id
        self.ts_born = ts_born
        self.ts_died = ts_died
        self.age = 0
        self.alive = True
        self.active = -1

    def agedieGrow(self):

        self.age += 1

        if self.age == 10000:
            #print('a tree dies')
             ### Killing Tree

            self.ts_died = self.model.timestep
            self.alive = False

            row = [self.model.run_id,
                   self.unique_id,
                   self.pos[0],
                   self.pos[1],
                   self.ts_born,
                   self.alive,
                   self.ts_died,
                   self.age]

            conn = connect_db(self.model.sql)
            add_tree_data(conn, row)

            ## Growing Tree

            new_loc = self.model.grid.get_neighborhood(self.pos, moore=True, include_center=False, radius=10)
            new_loc = self.random.choice(new_loc)
            new_tree = NutTree(self.model.next_id(), self.model, ts_born=self.model.timestep)
            self.model.grid.place_agent(new_tree, new_loc)
            self.model.schedule.add(new_tree)

            ## Remove dead Tree from Model
            self.model.grid.remove_agent(self)
            self.model.schedule.remove(self)
            self.model.tree_growth_deaths += 1

        else:
            pass




    def step(self):

        if self.model.__getattribute__("treesdie") is True:
            self.agedieGrow()

        else:
            pass

class PoundingTool(Agent):
    def __init__(self, unique_id, model, tool_size, active, s_id, parent_id="OG", q=-1, born=-1):
        super().__init__(unique_id, model)
        self.parent_id = parent_id
        self.tool_id = get_random_alphanumeric_string(8)
        self.Tool_size = tool_size
        self.original_size = tool_size
        self.active = active
        self.source_id = s_id
        self.rm_quality = q
        self.ts_born = born
        self.ts_died = -1
        self.n_uses = 0

